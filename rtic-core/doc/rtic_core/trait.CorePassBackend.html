<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Interface for providing the low-level hardware bindings specific for a target(s) (A.k.a The Backend) to be used during code generation phase of the *Core Compilation Pass."><title>CorePassBackend in rtic_core - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="rtic_core" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../rtic_core/index.html">rtic_core</a><span class="version">0.1.0</span></h2></div><h2 class="location"><a href="#">CorePassBackend</a></h2><div class="sidebar-elems"><section><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.default_task_priority">default_task_priority</a></li><li><a href="#tymethod.generate_global_definitions">generate_global_definitions</a></li><li><a href="#tymethod.generate_interrupt_free_fn">generate_interrupt_free_fn</a></li><li><a href="#tymethod.generate_resource_proxy_lock_impl">generate_resource_proxy_lock_impl</a></li><li><a href="#tymethod.populate_idle_loop">populate_idle_loop</a></li><li><a href="#tymethod.post_init">post_init</a></li><li><a href="#tymethod.pre_codgen_validation">pre_codgen_validation</a></li><li><a href="#tymethod.set_entry_name">set_entry_name</a></li><li><a href="#tymethod.wrap_task_execution">wrap_task_execution</a></li></ul><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In crate rtic_core</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="index.html">rtic_core</a>::<wbr><a class="trait" href="#">CorePassBackend</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/rtic_core/backend.rs.html#5-222">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait CorePassBackend {
    // Required methods
    fn <a href="#tymethod.post_init" class="fn">post_init</a>(
        &amp;self,
        app_args: &amp;<a class="struct" href="struct.AppArgs.html" title="struct rtic_core::AppArgs">AppArgs</a>,
        app_info: &amp;<a class="struct" href="struct.SubApp.html" title="struct rtic_core::SubApp">SubApp</a>,
        app_analysis: &amp;<a class="struct" href="struct.SubAnalysis.html" title="struct rtic_core::SubAnalysis">SubAnalysis</a>,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://docs.rs/proc-macro2/1.0.78/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream2</a>&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.generate_resource_proxy_lock_impl" class="fn">generate_resource_proxy_lock_impl</a>(
        &amp;self,
        app_args: &amp;<a class="struct" href="struct.AppArgs.html" title="struct rtic_core::AppArgs">AppArgs</a>,
        app_info: &amp;<a class="struct" href="struct.SubApp.html" title="struct rtic_core::SubApp">SubApp</a>,
        incomplete_lock_fn: <a class="struct" href="https://docs.rs/syn/2.0.48/syn/item/struct.ImplItemFn.html" title="struct syn::item::ImplItemFn">ImplItemFn</a>,
    ) -&gt; <a class="struct" href="https://docs.rs/syn/2.0.48/syn/item/struct.ImplItemFn.html" title="struct syn::item::ImplItemFn">ImplItemFn</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.generate_global_definitions" class="fn">generate_global_definitions</a>(
        &amp;self,
        app_args: &amp;<a class="struct" href="struct.AppArgs.html" title="struct rtic_core::AppArgs">AppArgs</a>,
        app_info: &amp;<a class="struct" href="struct.SubApp.html" title="struct rtic_core::SubApp">SubApp</a>,
        app_analysis: &amp;<a class="struct" href="struct.SubAnalysis.html" title="struct rtic_core::SubAnalysis">SubAnalysis</a>,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://docs.rs/proc-macro2/1.0.78/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream2</a>&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.wrap_task_execution" class="fn">wrap_task_execution</a>(
        &amp;self,
        task_prio: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u16.html">u16</a>,
        dispatch_task_call: <a class="struct" href="https://docs.rs/proc-macro2/1.0.78/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream2</a>,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://docs.rs/proc-macro2/1.0.78/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream2</a>&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.set_entry_name" class="fn">set_entry_name</a>(&amp;self, core: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u32.html">u32</a>) -&gt; <a class="struct" href="https://docs.rs/proc-macro2/1.0.78/proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.populate_idle_loop" class="fn">populate_idle_loop</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://docs.rs/proc-macro2/1.0.78/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream2</a>&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.generate_interrupt_free_fn" class="fn">generate_interrupt_free_fn</a>(&amp;self, empty_body_fn: <a class="struct" href="https://docs.rs/syn/2.0.48/syn/item/struct.ItemFn.html" title="struct syn::item::ItemFn">ItemFn</a>) -&gt; <a class="struct" href="https://docs.rs/syn/2.0.48/syn/item/struct.ItemFn.html" title="struct syn::item::ItemFn">ItemFn</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.pre_codgen_validation" class="fn">pre_codgen_validation</a>(
        &amp;self,
        app: &amp;<a class="struct" href="struct.App.html" title="struct rtic_core::App">App</a>,
        analysis: &amp;<a class="struct" href="struct.Analysis.html" title="struct rtic_core::Analysis">Analysis</a>,
    ) -&gt; <a class="type" href="https://docs.rs/syn/2.0.48/syn/error/type.Result.html" title="type syn::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.default_task_priority" class="fn">default_task_priority</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u16.html">u16</a>;
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Interface for providing the low-level hardware bindings specific for a target(s) (A.k.a The Backend) to be used during code generation phase
of the *<em>Core Compilation Pass</em>.</p>
</div></details><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.post_init" class="method"><a class="src rightside" href="../src/rtic_core/backend.rs.html#24-29">source</a><h4 class="code-header">fn <a href="#tymethod.post_init" class="fn">post_init</a>(
    &amp;self,
    app_args: &amp;<a class="struct" href="struct.AppArgs.html" title="struct rtic_core::AppArgs">AppArgs</a>,
    app_info: &amp;<a class="struct" href="struct.SubApp.html" title="struct rtic_core::SubApp">SubApp</a>,
    app_analysis: &amp;<a class="struct" href="struct.SubAnalysis.html" title="struct rtic_core::SubAnalysis">SubAnalysis</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://docs.rs/proc-macro2/1.0.78/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream2</a>&gt;</h4></section></summary><div class="docblock"><h5 id="setting-up-the-system"><a class="doc-anchor" href="#setting-up-the-system">§</a>Setting up the system</h5>
<p>Implementation must return the TokenStream to be inserted <strong>AFTER</strong> the call to Global <code>#[init]</code> and tasks init() functions,
and <strong>BEFORE</strong> starting the idle task.</p>
<p>Note that the generated code resulting from the returned TokenStream will be wrapped in a critical section (interrupts
are disabled at start and re-enabled at end)</p>
<h6 id="use-case"><a class="doc-anchor" href="#use-case">§</a>Use case</h6>
<p>This trait method is meant to cover the following use cases:</p>
<ul>
<li>enabling interrupt lines used by the application</li>
<li>setting priority of interrupts, and similar initializations depending on specific hardware details</li>
<li>multicore systems where a master core needs to wake-up and initialize other cores (see rp2040 distribution as an example)</li>
</ul>
<h6 id="note"><a class="doc-anchor" href="#note">§</a>Note</h6>
<p>This function will be called several times in case of a multicore system, each time with different <code>app_info</code> and <code>app_analysis</code>.</p>
<h6 id="arguments"><a class="doc-anchor" href="#arguments">§</a>Arguments</h6>
<ul>
<li><code>app_args</code>: arguments provided to the #[app(…)] macro attribute, this includes paths to PACs, number of cores…</li>
<li><code>app_info</code>: Contains the parsed user application. For single core this will be the full application. For multicore, this represents only a sub-application corresponding to a specific core.</li>
<li><code>app_analysis</code>: Information about the analyzed application. For single core this will be the analysis of the full application. For multicore, this represents the analysis of a sub-application corresponding to a specific core.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.generate_resource_proxy_lock_impl" class="method"><a class="src rightside" href="../src/rtic_core/backend.rs.html#81-86">source</a><h4 class="code-header">fn <a href="#tymethod.generate_resource_proxy_lock_impl" class="fn">generate_resource_proxy_lock_impl</a>(
    &amp;self,
    app_args: &amp;<a class="struct" href="struct.AppArgs.html" title="struct rtic_core::AppArgs">AppArgs</a>,
    app_info: &amp;<a class="struct" href="struct.SubApp.html" title="struct rtic_core::SubApp">SubApp</a>,
    incomplete_lock_fn: <a class="struct" href="https://docs.rs/syn/2.0.48/syn/item/struct.ImplItemFn.html" title="struct syn::item::ImplItemFn">ImplItemFn</a>,
) -&gt; <a class="struct" href="https://docs.rs/syn/2.0.48/syn/item/struct.ImplItemFn.html" title="struct syn::item::ImplItemFn">ImplItemFn</a></h4></section></summary><div class="docblock"><h5 id="srp-based-resource-locking-implementation"><a class="doc-anchor" href="#srp-based-resource-locking-implementation">§</a>SRP-based Resource locking implementation</h5>
<p>The provided method argument <code>incomplete_lock_fn</code> holds the TokenStream representation of an incomplete function named <code>lock</code> responsible for locking a distinct resource in the system. The distribution must generate the missing target-specific logic for implementing the locking of that resource.</p>
<p>To illustrate this further with an example, let’s assume the user defined the following shared resources:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Before code expansion
</span><span class="attr">#[shared]
</span><span class="kw">struct </span>Shared {
    <span class="kw">pub </span>resource1: R1Type
}</code></pre></div>
<p>Every field of the shared resources struct has a corresponding autogenerated <strong>resource proxy</strong> struct that implements the <code>RticMutex</code> internal trait. as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>__resource1_mutex {
    <span class="attr">#[doc(hidden)]
    </span>task_priority: u16,
}
<span class="kw">impl </span>RticMutex <span class="kw">for </span>__resource1_mutex {
    <span class="kw">type </span>ResourceType = R1Type;
    <span class="comment">// this is what the trait method argument `incomplete_lock_fn` expands to
    </span><span class="kw">fn </span>lock(<span class="kw-2">&amp;mut </span><span class="self">self</span>, f: <span class="kw">impl </span>FnOnce(<span class="kw-2">&amp;mut </span><span class="self">Self</span>::ResourceType)) {
        <span class="kw">const </span>CEILING: u16 = <span class="number">3u16</span>; <span class="comment">// resource ceiling
        </span><span class="kw">let </span>task_priority = <span class="self">self</span>.task_priority; <span class="comment">// current task priority
        </span><span class="kw">let </span>resource_ref = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;mut </span>SHARED.assume_init_mut().resource1 };
        <span class="comment">/* TODO: THE HARDWARE-SPECIFIC CODE COMES HERE */
    </span>}
}</code></pre></div>
<p>Each time RTIC needs to generate an implementation of the <code>RticMutex</code> trait for a <strong>resource proxy</strong>, it calls the method <a href="trait.CorePassBackend.html#tymethod.generate_resource_proxy_lock_impl" title="method rtic_core::CorePassBackend::generate_resource_proxy_lock_impl">CorePassBackend::generate_resource_proxy_lock_impl</a> to ask the backend to populate the missing details of the [lock] function for that particular resource.</p>
<h6 id="contract"><a class="doc-anchor" href="#contract">§</a>Contract</h6>
<ul>
<li>
<p>The returned value representing the populated function must have the same signature as `incomplete_lock_fn’.</p>
</li>
<li>
<p>The implementation must be according to SRP rules such that:</p>
<ul>
<li>System interrupt priority ceiling is raised to the value of <code>CEILING</code>.</li>
<li>The closure <code>f</code> is called and <code>resource_ref</code> is passed to it as a parameter. (to execute the resource critical section).</li>
<li>System interrupt priority ceiling should be restored back to <code>task_priority</code> value.</li>
</ul>
</li>
<li>
<p>If global definitions need to be generated for use in the locking implementation, the trait method which will be described next should be used to cover such need.</p>
</li>
</ul>
<h6 id="note-1"><a class="doc-anchor" href="#note-1">§</a>Note</h6>
<p>This trait method is called for every shared resource in every sub-application.</p>
<h6 id="debugging-tip"><a class="doc-anchor" href="#debugging-tip">§</a>Debugging Tip</h6>
<p>Use <code>eprintln(&quot;{}&quot;, incomplete_lock_fn.to_tokenstream().to_string())</code> to see the <code>incomplete_lock_fn</code> signature and already provided logic inside it.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.generate_global_definitions" class="method"><a class="src rightside" href="../src/rtic_core/backend.rs.html#103-108">source</a><h4 class="code-header">fn <a href="#tymethod.generate_global_definitions" class="fn">generate_global_definitions</a>(
    &amp;self,
    app_args: &amp;<a class="struct" href="struct.AppArgs.html" title="struct rtic_core::AppArgs">AppArgs</a>,
    app_info: &amp;<a class="struct" href="struct.SubApp.html" title="struct rtic_core::SubApp">SubApp</a>,
    app_analysis: &amp;<a class="struct" href="struct.SubAnalysis.html" title="struct rtic_core::SubAnalysis">SubAnalysis</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://docs.rs/proc-macro2/1.0.78/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream2</a>&gt;</h4></section></summary><div class="docblock"><h5 id="implementation-specific-pre-computed-values-and-global-definitions"><a class="doc-anchor" href="#implementation-specific-pre-computed-values-and-global-definitions">§</a>Implementation specific pre-computed values and global definitions</h5>
<p>When the Implementation requires pre-computed constants, additional global `use’ statements or additional function definitions that must to be accessible from the global application scope, the above trait method could be implemented to return the TokenStream representing those global definitions.</p>
<h6 id="example-use-case"><a class="doc-anchor" href="#example-use-case">§</a>Example Use case</h6>
<p>A practical example could be the RTIC implementation for a cortex M0/M0+ based MCU, where locking is implemented using Interrupt priority masking, where the masks are statically computed values accessible from the global application scope. The masks computation can and should use the information provided by <code>app_args</code>, <code>app_info</code> and <code>app_analysis</code> arguments.</p>
<p>For a real example, see the rp2040 distribution which targets a cortex M0+ based MCU.</p>
<h6 id="note-2"><a class="doc-anchor" href="#note-2">§</a>Note</h6>
<p>This function will be called several times in case of a multicore system, each time with different <code>app_info</code> and <code>app_analysis</code> for each core.</p>
<h6 id="arguments-1"><a class="doc-anchor" href="#arguments-1">§</a>Arguments</h6>
<ul>
<li><code>app_args</code>: arguments provided to the #[app(…)] macro attribute, this includes paths to PACs, number of cores…</li>
<li><code>app_info</code>: Contains the parsed user application. For single core this will be the full application. For multicore, this represents only a sub-application corresponding to a specific core.</li>
<li><code>app_analysis</code>: Information about the analyzed application. For single core this will be the analysis of the full application. For multicore, this represents the analysis of a sub-application corresponding to a specific core.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.wrap_task_execution" class="method"><a class="src rightside" href="../src/rtic_core/backend.rs.html#121-125">source</a><h4 class="code-header">fn <a href="#tymethod.wrap_task_execution" class="fn">wrap_task_execution</a>(
    &amp;self,
    task_prio: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u16.html">u16</a>,
    dispatch_task_call: <a class="struct" href="https://docs.rs/proc-macro2/1.0.78/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream2</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://docs.rs/proc-macro2/1.0.78/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream2</a>&gt;</h4></section></summary><div class="docblock"><h5 id="wrapping-task-execution"><a class="doc-anchor" href="#wrapping-task-execution">§</a>Wrapping task execution</h5>
<p>In certain cases, some code needs to be executed before and after the [exec] method of a task is called within an interrupt handler. To allow this “wrapping” of the task execution, this trait method can be implemented. The statement from calling the task’s [exec] method has been provided as input to this trait method (<code>dispatch_task_call</code>), If you return a Some(tokenstream), the returned TokenStream must include/wrap the <code>dispatch_task_call</code>.</p>
<h6 id="example-use-case-1"><a class="doc-anchor" href="#example-use-case-1">§</a>Example use case</h6>
<p>An example could be an implementation for cortex M MCUs that support a BASEPRI register. Every time an interrupt handler id called, the current value of BASEPRI needs to be saved, then task [exec] method is called, then the saved BASEPRI value is restored.</p>
<h6 id="arguments-2"><a class="doc-anchor" href="#arguments-2">§</a>Arguments</h6>
<ul>
<li><code>dispatch_task_call</code>: call to the task [exec] method.</li>
</ul>
<h6 id="contract-1"><a class="doc-anchor" href="#contract-1">§</a>Contract</h6>
<p>The <code>dispatch_task_call</code> token stream must be placed in between your custom logic. This tokenstream must not be mutated.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.set_entry_name" class="method"><a class="src rightside" href="../src/rtic_core/backend.rs.html#148">source</a><h4 class="code-header">fn <a href="#tymethod.set_entry_name" class="fn">set_entry_name</a>(&amp;self, core: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u32.html">u32</a>) -&gt; <a class="struct" href="https://docs.rs/proc-macro2/1.0.78/proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a></h4></section></summary><div class="docblock"><h5 id="entry-name-for-a-specific-core"><a class="doc-anchor" href="#entry-name-for-a-specific-core">§</a>Entry name for a specific core</h5>
<p>This trait method allows specifying the name of the entry function on each core.</p>
<h6 id="use-case-1"><a class="doc-anchor" href="#use-case-1">§</a>Use case</h6>
<p>This trait method is especially useful for multicore applications that result in a single output binary (single-binary systems)
where there are multiple entries (one for each core) but only one entry must to be named <code>main</code> while other entries are given
other unique identifiers.</p>
<h6 id="contract-2"><a class="doc-anchor" href="#contract-2">§</a>Contract</h6>
<ul>
<li>For single-core and multi-binary multicore distributions, this trait method should always return “main” as the entry name.</li>
<li>For single-binary multicore distributions, return “main” once only, then different identifiers should be used for other cores entries.</li>
</ul>
<p>See rp2040 distribution for a real world example.</p>
<p>By default you should implement this function as</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>entry_name(<span class="kw-2">&amp;</span><span class="self">self</span>, core: u32) -&gt; Ident {
    <span class="macro">format_ident!</span>(<span class="string">"main"</span>)
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.populate_idle_loop" class="method"><a class="src rightside" href="../src/rtic_core/backend.rs.html#166">source</a><h4 class="code-header">fn <a href="#tymethod.populate_idle_loop" class="fn">populate_idle_loop</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://docs.rs/proc-macro2/1.0.78/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream2</a>&gt;</h4></section></summary><div class="docblock"><h5 id="customizing-the-default-behavior-of-idle-task"><a class="doc-anchor" href="#customizing-the-default-behavior-of-idle-task">§</a>Customizing the default behavior of idle task</h5>
<p>When the user doesn’t define an idle task, RTIC automatically defines one with a default implementation.
The [exec] method of this default implementation contains an endless loop. This trait method allows customizing
what is executed inside that loop. For instance, the returned TokenStream can be a call to the <code>wfi</code> instruction
such that if the idle task is resumed, the device immediately goes to sleep mode and waits for more interrupts to
wake it up.</p>
<h5 id="customizing-the-default-behavior-of-idle-task-1"><a class="doc-anchor" href="#customizing-the-default-behavior-of-idle-task-1">§</a>Customizing the default behavior of idle task</h5>
<p>When the user doesn’t define an idle task, RTIC automatically defines one with a default implementation.
The [exec] method of this default implementation contains an endless loop. This trait method allows customizing
what is executed inside that loop. For instance, the returned TokenStream can be a call to the <code>wfi</code> instruction
such that if the idle task is resumed, the device immediately goes to sleep mode and waits for more interrupts to
wake it up.</p>
<p>If None is returned, the default implementation of the [exec] method of the idle task will be an empty infinite loop
that will only waste cycles !.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.generate_interrupt_free_fn" class="method"><a class="src rightside" href="../src/rtic_core/backend.rs.html#187">source</a><h4 class="code-header">fn <a href="#tymethod.generate_interrupt_free_fn" class="fn">generate_interrupt_free_fn</a>(&amp;self, empty_body_fn: <a class="struct" href="https://docs.rs/syn/2.0.48/syn/item/struct.ItemFn.html" title="struct syn::item::ItemFn">ItemFn</a>) -&gt; <a class="struct" href="https://docs.rs/syn/2.0.48/syn/item/struct.ItemFn.html" title="struct syn::item::ItemFn">ItemFn</a></h4></section></summary><div class="docblock"><h5 id="non-preemptable-code-sections"><a class="doc-anchor" href="#non-preemptable-code-sections">§</a>Non-preemptable code sections</h5>
<p>The RTIC implementation occasionally generates code that must run in a non-preemptable fashion. Therefore, a
distribution must provide the implementation of this trait method to populate the body of <code>empty_body_fn</code> with
the low-level implementation required to generate the function to be used to execute non-interruptible code
(i.e a traditional critical sections)</p>
<p>The <code>empty_body_fn</code> argument, is a token stream for a function that expands to the following:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[inline]
</span><span class="kw">pub fn </span>__rtic_critical_section&lt;F, R&gt;(f: F) -&gt; R
<span class="kw">where </span>F: FnOnce() -&gt; R,
{
   <span class="comment">/* TODO: You need to fill this part here */
</span>}</code></pre></div>
<h6 id="contract-3"><a class="doc-anchor" href="#contract-3">§</a>Contract</h6>
<ul>
<li>You MUST not change the function signature (of <code>empty_body_fn</code>)</li>
<li>The generated function must re-enable interrupts at end of the critical section.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.pre_codgen_validation" class="method"><a class="src rightside" href="../src/rtic_core/backend.rs.html#216">source</a><h4 class="code-header">fn <a href="#tymethod.pre_codgen_validation" class="fn">pre_codgen_validation</a>(&amp;self, app: &amp;<a class="struct" href="struct.App.html" title="struct rtic_core::App">App</a>, analysis: &amp;<a class="struct" href="struct.Analysis.html" title="struct rtic_core::Analysis">Analysis</a>) -&gt; <a class="type" href="https://docs.rs/syn/2.0.48/syn/error/type.Result.html" title="type syn::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><h5 id="additional-user-code-validation"><a class="doc-anchor" href="#additional-user-code-validation">§</a>Additional user code validation</h5>
<p>Implement this method to validate/analyze the resulting parsed and analyzed user application before the code generation phase starts.</p>
<h6 id="use-case-2"><a class="doc-anchor" href="#use-case-2">§</a>Use case</h6>
<p>In certain cases, some checks/validation related to implementation/hardware specific details need to be made before allowing the user code to be expanded.
An example, could be that the user has attempted to use an Exception line as for a dispatcher, but the distribution needs to forbid that.
Implementing this trait method, gives the ability to enforcing such checks.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.default_task_priority" class="method"><a class="src rightside" href="../src/rtic_core/backend.rs.html#219">source</a><h4 class="code-header">fn <a href="#tymethod.default_task_priority" class="fn">default_task_priority</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u16.html">u16</a></h4></section></summary><div class="docblock"><p>Implementation must return the default task priority to be used in idle task and tasks when priority argument value is not provided by the user.</p>
</div></details></div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"></div><script src="../trait.impl/rtic_core/backend/trait.CorePassBackend.js" async></script></section></div></main></body></html>